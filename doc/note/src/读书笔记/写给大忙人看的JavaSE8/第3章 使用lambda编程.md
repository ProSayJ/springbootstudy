# 第3章 使用lambda编程

当大伙儿都认为并行必然会成为未来的大趋势的时候，2014年底，Avoiding ping pong 论坛上，伟大的Linus Torvalds 提出了一个截然不同的观点：**  "忘掉那该死的并行吧！" **
> Give it up. The whole "parallel computing is the future" is a bunch of crock.


## 1.1　何去何从的并行计算 1
### 1.1.1　忘掉那该死的并行	2

> **[info] Linus Torvalds 是个传奇的人物：**
- 他给出了linux的原型,1991年网络上发布Linux源码。
- 2002起，Linus决定使用BitKeeper作为Linux内核开发的版本控制工具。
- 2005年，BitKeeper宣传发现Linux内核开发人员试图逆向解析BitKeeper内部协议，因此收回了授权。
- 基于上述的事前，Linus决定自己研究版本控制工具。于是Git诞生了。

---
> **[info] 并行的缺点：**
- 设计和是实现异常复杂
- 具体表现：(功能分离上、多线程的协调性、乱序性都会是程序正常执行的障碍)
- 混乱的程序难以阅读、难以理解、难以调试。

---
> **[info] 并行计算可以适用的领域：**
- 图像处理(如：大像素点的图片渲染)
- 服务器编程(如：批量订单处理、JVM的线程)

### 1.1.2　可怕的现实：摩尔定律的失效	4
> **[info] 什么是摩尔定律？ **
- 摩尔定律是由英特尔创始人之一戈登·摩尔提出来的。
- 每18个月到24个月，我们的计算机性能就能翻一番。
- 反过来说，就是每过18个月到24个月，你在未来用一半的价钱就能买到和现在性能相同的计算设备了。
- 在2004年，Intel宣布将4GHz芯片的发布时间推迟到2005年。
- 在2004年秋季，Intel宣布彻底取消4GHz计划。

---
> **[info] 摩尔定律在 CPU 的计算性能上可能己经失效： **
- CUP主频物理极限限制了硬件的发展。
- CPU遇到了不可逾越的瓶颈。




### 1.1.3　柳暗花明：不断地前进	5

> **[info]** 计算机性能提升的另外途径： **
- CPU核心在不断变多。2核、4核、8核
  
---
> **[info] 摩尔定律的另一个侧面： **  
- CPU核心数的增加18到24个月翻倍。
- 基于摩尔定律，硬件工程师无计可施，软件工程师来决心计算机效率问题:并行计算


### 1.1.4　光明或是黑暗	6
> **[info] 软件工程师的蛋疼的地方：**
- 一个物理CPU多个小cpu核心的硬件设计


## 1.2　你必须知道的几个概念	6
### 1.2.1　同步（Synchronous）和异步（Asynchronous）	7

![同步和异步](image/chapter_01/同步和异步.png)
<center>同步和异步</center>

> **[info] 同步和异步的描述：**
- 同步和异步通常用来形容一次方法调用。
- 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为 。
- 异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法通常会在另外一个线程中 “真实” 地执行。整个过程 ，不会阻碍调用者的工作。
- 对于调用者来说：异步调用似乎是一瞬间就完成的。如果异步调用需要返回结果，那么当这个异步调用真实完成时，则会通知调用者。


### 1.2.2　并发（Concurrency）和并行（Parallelism）	8

![并发和并行](image/chapter_01/并发和并行.png)
<center>并发和并行</center>

> **[info] 并发和并行的解释：**
- 严格意义上来说 ，并行的多个任务是真实的同时执行。
- 而对于并发来说 ，这个过程只是交替的，一会儿运行任务 A 一会儿执行任务 B，系统会不停地在两者间切换 。
- 但对于外部观察者来说，即使多个任务之间是串行并发的 ，也会造成多任务间是并行执行 的错觉。

### 1.2.3　临界区	9
- 临界区用来表示一种公共资源或者说是共享数据 ，可以被多个线程使用。
- 但是每一次，只能有一个线程使用它 ，一旦临界区资源被占用 ，其他线程要想使用这个资源，就必须等待。

### 1.2.4　阻塞（Blocking）和非阻塞（Non-Blocking）	9
** 阻塞和非阻塞通常用来形容多线程间的相互影响。**


> **[info] 阻塞 **
- 比如一个线程占用了临界区资源 ，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，这种情况就是阻塞。
- 此时，如果占用资源的线程一直不愿意释放资源 ，那么其他所有阻塞在这个临界区上的线程都不能工作。

---
> **[info] 非阻塞 **
- 非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行。
- 所有的线程都会尝试不断前向执行 。





### 1.2.5　死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）	9
** 死锁、饥饿和活锁都属于多线程的活跃性问题。 **

> **[info] 死锁（Deadlock）**
![死锁](image/chapter_01/死锁.png)
<center>死锁</center>

---
> **[info] 饥饿:（Starvation）**
- 是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。

---
> **[info] 活锁（Livelock）**
- 线程在某些情况下，且都秉承着 “谦让” 的原则，主动将资源释放给他人使用。
- 那么就会出现资源不断在两个线程中跳动，而没有一个线程可以同时拿到所有资源而正常执行，这种情况就是活锁。








## 1.3　并发级别	11
由于临界区的存在 ，多线程之间的并发必须受到控制。根据控制并发的策略 ，我们可以把并发的级别进行分类 ，大致上可以分为** 阻塞 、无饥饿、无障碍、无锁 、无等待**几种。

### 1.3.1　阻塞（Blocking）	11
- 一个线程是阻塞的,那么在其他线程释放资源之前，当前线程无法继续执行。
- 当我们使用 synchronized 关键字 ，或者重入锁时,我们得到的就是阻塞的线程。
- 阻塞的线程如果得不到临界区的值，线程就会被挂起等待，直到占有了所需资源为止。


### 1.3.2　无饥饿（Starvation-Free）	11
- 如果锁是公平的 ，满足先来后到 ，那么饥饿就不会产生。
- 不管新来的线程优先级多高 ，要想获得资源，就必须乖乖排队 。那么所有的线程都有机会执行。就是无饥饿。

![公平与非公平锁](image/chapter_01/公平与非公平锁.png)
<center>公平与非公平锁</center>


### 1.3.3　无障碍（Obstruction-Free）	12
- 无障碍是一种**最弱的非阻塞**调度。
- 两个线程如果是无障碍的执行，那么他们不会因为临界区的问题导致一方被挂起。
- 换言之，大家都可以大摇大摆地进入临界区了。
- 那么如果大家一起修改共享数据，把数据改坏了可怎么办呢？
- 对于无障碍的线程来说，一旦检测到这种情况，它就会立即对自己所做的修改进行回滚，确保数据安全。但如果没有数据竞争发生 ，那么线程就可以顺利完成自己的工作，走出临界区。

---
> **[info] 阻塞和非阻塞的策略:**
- 如果说阻塞的控制方式是悲观策略。(也就是说，系统认为两个线程之间很有可能发生不幸的冲突，因此，以保护共享数据为第一优先级。)
- 非阻塞的调度就是一种乐观的策略。(它认为多个线程之间很有可能不会发生冲突 ，或者说这种概率不大 。因此大家都应该无障碍的执行，但是一旦检测到冲突 ，就应该进行回滚。)

---
> **[info] 信号量简介：**
- 一种可行的无障碍实现可以依赖一个** <font color="red">一致性标记</font> ** 来实现。
- ** <font color="red">线程在操作之前 ，先读取并保存这个标记，在操作完成后，再次读取<font>**。
- 检查这个标记是否被更改过 ，如果两者是一致的 ， 则说明资源访问没有冲突。
- 如果不一致，则说明资源可能在操作过程中与其他写线程冲突，需要重试操作。
- 而任何对资源有修改操作的线程，在修改数据前 ，都需要更新这个一致性标记，表示数据不再安全。


### 1.3.4　无锁（Lock-Free）	12
- 无锁的并行都是无障碍的。
- 在无锁的情况下,所有的线程都能尝试对临界区进行访问。
- 但不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操代离开临界区 。

> **[info] 无锁中的自旋:**
- 在无锁的调用中，一个典型的特点是可能会包含一个无穷循环。
- 在这个循环中，线程会不断尝试修改共享变量。
- 如果没有冲突，修改成功，那么程序退出，否则继续尝试修改。
- 但无论如何，无锁的并行总能保证有一个线程是可以胜出的，不至于全军覆没。
- 至于临界区中竞争失败的线程，它们则必须不断重试，直到自己获胜。
- 如果运气很不好，总是尝试不成功，则会出现类似饥饿的现象，线程会停止不前。
  
``` java
while (!atomicVar.compareAndSet(localVar,localVar + 1)) {
    localVar = atornicVar .get () ;
}
```


### 1.3.5　无等待（Wait-Free）	13
- 无锁只要求有一个线程可以在有限步内完成操作，而无等待则在无锁的基础上更进一步进行扩展。
- 它要求所有的线程都必须在有限步内完成，这样就不会引起饥饿问题。
- 如果限制这个步骤上限，还可以进一步分解为有界无等待和线程数无关的无等待几种，它们之间的区别只是对循环次数的限制不同 。

> **[info] 无等待的典型结构:**
- 一种典型的无等待结构就是** <font color="red"> RCU (Read-Copy-Update)</font>**。
- 它的基本思想是:对数据的读可以不加控制。
- 因此,所有的读线程都是无等待的，它们既不会被锁定等待也不会引起任何冲突。 
- 但在写数据的时候，先取得原始数据的副本，接着只修改副本数据(这就是为什么读可以不加控制),修改完成后,在合适的时机回写数据。



## 1.4　有关并行的两个重要定律	13
### 1.4.1　Amdahl定律	13

> **[info] 无等待的典型结构:**
-  加速比定义：加速比＝优化前系统耗时/优化后系统耗时 

### 1.4.2　Gustafson定律	16
### 1.4.3　Amdahl定律和Gustafson定律是否相互矛盾	16

## 1.5　回到Java：JMM	17
多线程的几个特性：** <font color="red">原子性、可见性、有序性</font> **

### 1.5.1　原子性（Atomicity）	18
> **[info] 定义和举例:**
- 原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
- 比如，对于一个静态全局变量int i，两个线程同时对它赋值 ，线程A给他赋值1，线程B给它赋值为-1。那么不管这2个线程以何种方式 、何种步调工作，i的值要么是1 ，要么是-1。线程A和线程B之间是没有干扰的 。这就是原子性的一个特点 ，不可被中断 。

### 1.5.2　可见性（Visibility）	20
> **[info] 定义和举例:**
- 可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。



### 1.5.3　有序性（Ordering）	22
### 1.5.4　哪些指令不能重排：Happen-Before规则	27

- 程序顺序原则 ：一个线程内保证语义的串行性
- volatile 规则：volatile变量的写,先发生于读,这保证了volatile变量的可见性。
- 锁规则:解锁(unlock)必然发生在随后的加锁(lock)前。
- 传递性:A先于B,B先于C，那么A必然先于C。
- 线程的start()方法先于它的每一个动作。
- 线程的所有操作先于线程的终结（Thread.join())。
- 线程的中断(interrupt())先于被中断线程的代码。
- 对象的构造函数执行、结束先于finalize()方法。


## 1.6　参考文献	27

> **[info] 参考文献:**
- [Linus Torvalds ：忘掉那该死的并行吧 ！](https://www.csdn.net/article/2015-01-08/)
- [JVM规范](https://docs.oracle.com/javase/specs/jls/se7/html/jls-17.html#jls-17.4)